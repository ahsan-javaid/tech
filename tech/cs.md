15 problem patterns that will help you solve problems faster, easier, and more efficiently:

 1. Prefix Sum
 Use: Problems requiring sum queries of subarrays.
 - Efficient for multiple range sum queries.
 - Reduces time complexity using precomputed prefix sums.

 2. Two Pointers
 Use: String and array problems involving comparisons.
 - Efficient for palindrome checks and finding pairs.
 - Moves pointers inward/outward for reduced time complexity.

 3. Sliding Window
 Use: Finding subarrays/substrings with specific criteria.
 - Ideal for problems involving maximum/minimum subarray sums.
 - Moves a fixed window across the array to avoid recalculating.

 4. Fast and Slow Pointers
 Use: Linked lists and cyclic problems.
 - Detects cycles in linked lists or arrays.
 - Finds the middle element in one pass.

 5. Linked List In-Place Reversal
 Use: Linked list problems requiring pointer rearrangement.
 - Reverses or manipulates linked lists in one pass.
 - Avoids extra space and multiple iterations.

 6. Monotonic Stack
 Use: Problems involving next greater/smaller elements.
 - Tracks elements in a stack to find the next element efficiently.
 - Optimizes nested loop operations into linear time.

 7. Top K Elements
 Use: Finding K largest/smallest elements.
 - Uses heaps to keep track of the K largest/smallest elements.
 - More efficient than sorting the array.

 8. Overlapping Intervals
 Use: Problems involving intervals or ranges.
 - Efficient for merging, inserting, or finding overlapping intervals.
 - Sorts intervals and merges overlapping ones.

 9. Modified Binary Search
 Use: Searching in rotated or nearly sorted arrays.
 - Adapts binary search for non-perfectly sorted arrays.
 - Efficient for problems like finding the smallest element in a rotated array.

 10. Binary Tree Traversal
 Use: Traversing binary trees in specific orders.
 - Pre-order, in-order, post-order, and level-order traversal.
 - Suitable for problems like copying, deleting, or serializing trees.

 11. Depth First Search (DFS)
 Use: Exploring all paths in graphs or trees.
 - Ideal for pathfinding, cycle detection, or component counting.
 - Explores deep into branches before backtracking.

 12. Breadth First Search (BFS)
 Use: Level-by-level traversal of trees or graphs.
 - Useful for shortest path and connected component problems.
 - Traverses nodes level by level using a queue.

 13. Matrix Traversal
 Use: Grid or matrix problems, like finding islands.
 - Treats the matrix as a graph for DFS/BFS.
 - Ideal for problems requiring adjacent cell exploration.

 From: https://www.linkedin.com/posts/karan-saxena-466b07190_leetcode-is-less-about-the-number-of-problems-activity-7239624003852595200-T1JE?utm_source=share&utm_medium=member_desktop 
 